{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"About","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\n\nimport pysbml\n</pre> from pathlib import Path  import pysbml In\u00a0[2]: Copied! <pre>model = pysbml.load_and_transform_model(Path(\"assets\") / \"00462.xml\")\nmodel\n</pre> model = pysbml.load_and_transform_model(Path(\"assets\") / \"00462.xml\") model Out[2]: <p>We also supply a <code>codegen</code> function to directly transform your model into a Python module that you can execute.</p> In\u00a0[3]: Copied! <pre>from pysbml.codegen import codegen\n\nprint(codegen(model))\n</pre> from pysbml.codegen import codegen  print(codegen(model)) <pre>import math\nimport scipy.special\nimport pandas as pd\n\ntime: float = 0.0\nk1: float = 1.00000000000000\nC: float = 1.00000000000000\nS1: float = 0.000150000000000000\nS2: float = 0.0\n\n# Initial assignments\nreaction1 = S1*k1\ny0 = [S1, S2]\nvariable_names = ['S1', 'S2']\n\ndef model(time: float, variables: tuple[float, ...]) -&gt; tuple[float, ...]:\n    S1, S2 = variables\n    reaction1: float = S1*k1\n    dS1dt: float = -reaction1\n    dS2dt: float = reaction1\n    return dS1dt, dS2dt\n\n\ndef derived(time: float, variables: tuple[float, ...]) -&gt; dict[str, float]:\n    S1, S2 = variables\n    reaction1: float = S1*k1\n    return {\n        'reaction1': reaction1,\n    }\n</pre> In\u00a0[4]: Copied! <pre>from pysbml import load_document\n\ndoc = load_document(Path(\"assets\") / \"00462.xml\")\ndoc.model\n</pre> from pysbml import load_document  doc = load_document(Path(\"assets\") / \"00462.xml\") doc.model Out[4]: In\u00a0[5]: Copied! <pre>from pysbml.transform import transform\n\nmodel = transform(doc)\nmodel\n</pre> from pysbml.transform import transform  model = transform(doc) model Out[5]: In\u00a0[6]: Copied! <pre>print(model._repr_markdown_())\n</pre> print(model._repr_markdown_()) <pre># case00462\n# Parameters\n| name | value | unit | \n| --- | --- | --- | \n| k1 | 1.00000000000000 | None | \n| C | 1.00000000000000 | None | \n# Variables\n| name | value | unit | \n| --- | --- | --- | \n| S1 | $0.000150000000000000$ | None | \n| S2 | $0.0$ | None | \n# Reactions\n| name | fn | stoichiometry | \n| --- | --- | --- | \n| reaction1 | $S1*k1$ | {'S1': -1.00000000000000, 'S2': 1.00000000000000} | \n</pre> In\u00a0[7]: Copied! <pre>print(codegen(model))\n</pre> print(codegen(model)) <pre>import math\nimport scipy.special\nimport pandas as pd\n\ntime: float = 0.0\nk1: float = 1.00000000000000\nC: float = 1.00000000000000\nS1: float = 0.000150000000000000\nS2: float = 0.0\n\n# Initial assignments\nreaction1 = S1*k1\ny0 = [S1, S2]\nvariable_names = ['S1', 'S2']\n\ndef model(time: float, variables: tuple[float, ...]) -&gt; tuple[float, ...]:\n    S1, S2 = variables\n    reaction1: float = S1*k1\n    dS1dt: float = -reaction1\n    dS2dt: float = reaction1\n    return dS1dt, dS2dt\n\n\ndef derived(time: float, variables: tuple[float, ...]) -&gt; dict[str, float]:\n    S1, S2 = variables\n    reaction1: float = S1*k1\n    return {\n        'reaction1': reaction1,\n    }\n</pre> <p>If you have a library yourself and want to just use our transformed model to create your own code, great! We do the same at MxlPy.</p> <p>A few pointers for that to work seamlessly:</p> <ol> <li>Derived values are stored as dictionaries internally. Depending on how you set up your models, you will need to sort these such that they are called in the right sequence (as they might depend on each other). Since this is essentially a dependency resolution problem, we implemented a topological sort for this. Take a look at <code>pysbml.codegen._sort_dependencies</code> for inspiration how to do this</li> <li>Initial assignments have the same issue. Since they can depend on derived values, we recommend sorting twice: once with the initial ones and once without</li> <li>It is legal SBML to have an ODE model without variables or ODEs. Be aware that your inputs and outputs might be empty</li> </ol>"},{"location":"index.html#pysbml","title":"pySBML\u00b6","text":"<p><code>pySBML</code> is a library to parse SBML models into native, type-annotated Python types and transform ODE models into a simpler representation.</p>"},{"location":"index.html#main-routine","title":"Main routine\u00b6","text":"<p>The main feature of pySBML is to read SBML models and then transform them into a simpler representation that directly can be interpreted as a system of ordinary differential equations.</p> <p>For a one-line solution, you can use the <code>load_and_transform_model</code> function.</p> <p>This supports both <code>Path</code> and <code>str</code> arguments, although the <code>pathlib.Path</code> solution is always preferred to support cross-platform scripts.</p> <p>Note that we defined a <code>_repr_markdown_</code> method for nice markdown display of a model in jupyter notebooks</p>"},{"location":"index.html#case00462","title":"case00462\u00b6","text":""},{"location":"index.html#parameters","title":"Parameters\u00b6","text":"name value unit k1 1.00000000000000 None C 1.00000000000000 None"},{"location":"index.html#variables","title":"Variables\u00b6","text":"name value unit S1 $0.000150000000000000$ None S2 $0.0$ None"},{"location":"index.html#reactions","title":"Reactions\u00b6","text":"name fn stoichiometry reaction1 $S1*k1$ {'S1': -1.00000000000000, 'S2': 1.00000000000000}"},{"location":"index.html#step-by-step","title":"Step by step\u00b6","text":"<p>If you want to inspect every step of the process, you can. In this case, we start by loading the entire SBML document, which contains plugin information and the actual model.</p>"},{"location":"index.html#step-1-loading-the-model","title":"Step 1: loading the model\u00b6","text":"<p>Using the <code>load_document</code> function, we parse the model into native Python types without further modifications.</p> <p>All SBML constructs as well as the mathml data is represented in a modern way, using type-annotated dataclasses. You can find these in <code>pysbml.parse.data</code> and <code>pysbml.parse.mathml</code> respectively.</p> <p>This representation will make it a lot easier to keep all variants in mind.</p> <p>For example, the <code>Reaction</code> class can contain locally defined parameters as well as stoichiometries which either map a variable directly to a factor or a tuple of factor and species reference. This is encoded as follows</p> <pre>@dataclass(kw_only=True, slots=True)\nclass Reaction:\n    body: Base\n    stoichiometry: Mapping[str, float | list[tuple[float, str]]]\n    args: list[Symbol]\n    local_pars: dict[str, Parameter] = field(default_factory=dict)\n</pre> <p>No untyped <code>model.getListOfReactions()</code> methods, just data. Simple and efficient.</p>"},{"location":"index.html#case00462","title":"case00462\u00b6","text":""},{"location":"index.html#compartment","title":"Compartment\u00b6","text":"name size is_constant C 1.0 True"},{"location":"index.html#variables","title":"Variables\u00b6","text":"name amount conc constant substance_units compartment only_substance_units boundary_condition S1 None 0.00015 False substance C False False S2 None 0.0 False substance C False False"},{"location":"index.html#parameters","title":"Parameters\u00b6","text":"name value is_constant unit k1 1.0 True"},{"location":"index.html#reactions","title":"Reactions\u00b6","text":"name body args stoichiometry local pars reaction1 C * k1 * S1 [C, k1, S1] {'S1': -1.0, 'S2': 1.0} {}"},{"location":"index.html#step-2-transforming-the-model","title":"Step 2: transforming the model\u00b6","text":"<p>As you can see above, the SBML standard contains a lot of different flags and options for what e.g. a Variable is supposed to mean.</p> <p>This includes whether the variable is an amount, a concentration, constant, is to be interpreted as an amount (<code>only_substrate_units</code>), has a boundary condition, lives in a constant or dynamic comparment and so on.</p> <p>To us that representation is too complex. We want something simpler. Using the <code>transform</code> method, we can represent the model using just the data below.</p> <pre>type Expr = sympy.Symbol | sympy.Float | sympy.Expr\ntype Stoichiometry = dict[str, Expr]\n\nclass Parameter:\n    value: sympy.Float\n    unit: Quantity | None\n\nclass Variable:\n    value: sympy.Float\n    unit: Quantity | None\n\nclass Reaction:\n    expr: sympy.Expr\n    stoichiometry: Stoichiometry\n\nclass Model:\n    name: str\n    units: dict[str, Quantity] = field(default_factory=dict)\n    functions: dict[str, Expr] = field(default_factory=dict)\n    parameters: dict[str, Parameter] = field(default_factory=dict)\n    variables: dict[str, Variable] = field(default_factory=dict)\n    derived: dict[str, Expr] = field(default_factory=dict)\n    reactions: dict[str, Reaction] = field(default_factory=dict)\n    initial_assignments: dict[str, Expr] = field(default_factory=dict)\n</pre> <p>Parameters are always constant, variables always change. No special handling of compartments, no locally defined parameters.</p> <p>Note that we also transformed the MathML classes into sympy expressions for easier manipulation.</p>"},{"location":"index.html#case00462","title":"case00462\u00b6","text":""},{"location":"index.html#parameters","title":"Parameters\u00b6","text":"name value unit k1 1.00000000000000 None C 1.00000000000000 None"},{"location":"index.html#variables","title":"Variables\u00b6","text":"name value unit S1 $0.000150000000000000$ None S2 $0.0$ None"},{"location":"index.html#reactions","title":"Reactions\u00b6","text":"name fn stoichiometry reaction1 $S1*k1$ {'S1': -1.00000000000000, 'S2': 1.00000000000000}"},{"location":"index.html#step-3-codegen","title":"Step 3: codegen\u00b6","text":"<p>As above, you can use our <code>codegen</code> function to directly generate a model.</p>"}]}